
class Foo
{
public:

//в качестве переменной, отвечающий за размер массива, лучше использовать переменную, чье название не совпадает с переменными, которые мы используем для итерации 
    Foo(int j) 
    { 
//в качестве названий массивов лучше не использовать переменные i,j, которые используются для итерации
        i = new int[j]; 
    }
	
//Необходимо прописать virtual ~Foo, иначе могут возникнуть проблемы с вызовом деструктора ~Foo в классах-потомках, что приведет к тому, что память не очистится 
    
	~Foo() { delete i; } //неверное удаление массива
	
private:
	int* i; 
};

// Отсутствует спецификатор доступа public. Таким образом, мы не сможем получить доступ к тому, что находится в public поле родительского класса Foo
class Bar : Foo
{
public:
// Переименовать переменные i,j
//прописать Bar (int n) : Foo(n), иначе выводится ошибка "нет конструктора по умолчанию" для класса Bar
    Bar(int j) { i = new char[j]; }
//Необоходимо прописать virtual, чтобы корректно отработали два деструктора (~Bar, затем ~Foo) и память очистилась
    ~Bar() 
	{ 
		delete i; // неверное удаление массива 
	}
private:
    char* i; // переименуем массив 
};

//Лучше изменить на int main и в конце кода вывести return 0, чтобы понимать, что программа завершена корректно. В случае с void это сделать затруднительнее
void main()
{
    Foo* f = new Foo(100);
    Foo* b = new Bar(200);
    *f = *b; // для выполнения этой опреации необходимо в классе Foo определить конструктор копирования и оператор присваивания
// А также нужно сделать проверку, возможно ли перепресвоить массивы. Если размеры массивов не совпадают, то опреация присваивания не поддерживается
    delete f;
    delete b;
}
